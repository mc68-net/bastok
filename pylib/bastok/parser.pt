from    bastok.parser  import *
from    bastok.charset  import UTCharset
import  struct
import  pytest

####################################################################
#   Support routines

DIGITS_2 = set(['0', '1'])
DIGITS_8 = DIGITS_2 | set(['2', '3', '4', '5', '6', '7'])
DIGITS_10 = DIGITS_8 | set(['8', '9'])
DIGITS_16 = DIGITS_10 \
    | set(['A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f'])

@pytest.mark.parametrize('base, digitchars', [
    (2, DIGITS_2), (8, DIGITS_8), (10, DIGITS_10), (16, DIGITS_16),
])
def test_basedigits(base, digitchars):
    print(sorted(digitchars))
    assert digitchars == basedigits(base)

####################################################################
#   Minimal parser functionality on which other tests depend

def test_encode_elem_str():
    p = Parser('')
    assert '1' == p.encode_elem('1')
    with pytest.raises(ValueError) as ex:
        p.encode_elem('23')
    assert ex.match("encode_elem argument length 2 != 1 for '23'")

def test_encode_seq_str():
    p = Parser('')
    assert '1' == p.encode_seq('1')
    assert '23' == p.encode_seq('23')

def test_encode_elem_bytes():
    p = Parser(b'', TestCodec())
    assert 49 == p.encode_elem('1')
    with pytest.raises(ValueError) as ex:
        p.encode_elem('23')
    assert ex.match("encode_elem argument length 2 != 1 for '23'")

def test_encode_seq_bytes():
    p = Parser(b'', TestCodec())
    assert b'1' == p.encode_seq('1')
    assert b'23' == p.encode_seq('23')

def test_parser_consume_str():
    p = Parser('abcdef')
    c = p.consume
    assert ('a', 'bc') == (c(1), c(2))
    with pytest.raises(p.ParseError) as ex:
        c(4)
    assert ex.match('Unexpected end of input: 7 > 6')
    assert    'def' == p.remain()
    assert 'abcdef' == p.uncommitted()
    p.commit()
    assert    'def' == p.remain()

def test_parser_consume_bytes():
    p = Parser(b'abcdef')
    c = p.consume
    assert (b'a', b'bc') == (c(1), c(2))
    with pytest.raises(p.ParseError) as ex:
        c(4)
    assert ex.match('Unexpected end of input: 7 > 6')
    assert b'abcdef' == p.uncommitted()
    p.commit()
    assert b'def' == p.remain()

def test_Parser_commit():
    p = Parser(b'abcd')
    c = p.consume

    assert b'abcd' == p.uncommitted()

    p.start()
    assert (b'a', b'bcd', b'abcd') == (c(), p.remain(), p.uncommitted())
    assert (b'b',  b'cd', b'abcd') == (c(), p.remain(), p.uncommitted())

    p.start()
    assert (b'a', b'bcd', b'abcd') == (c(), p.remain(), p.uncommitted())
    assert (b'b',  b'cd', b'abcd') == (c(), p.remain(), p.uncommitted())

    p.commit()
    assert b'cd' == p.remain()

    p.start()
    assert (b'c', b'd', b'cd') == (c(), p.remain(), p.uncommitted())

def test_parser_without_ASCII():
    ''' Test the parser with a codec that cannot convert any ASCII
        characters. Some parsing routines (e.g., `digits()`) won't work
        with such a codec, but so long as those are not called, we should
        still work fine.
    '''
    p = Parser(b'x', UTCharset())
    assert b'x' == p.consume(1)

####################################################################
#   Parser output generation.

@pytest.mark.parametrize('output, olist', [
    ('01234',           ['01', '2', '3', '4']),
    (b'\x00\x01\x02',   [b'\x00', b'\x01\x02']),
    #   XXX It's not clear what we should give for the output if we can't
    #   figure out what type it should be, so for the moment, just None.
    (None,              []),
])
def test_Parser_generate_output_types(output, olist):
    p = Parser('');
    for o in olist:
        assert None is p.output_pending()
        p.generate(o)
        assert o == p.output_pending()
        p.commit()
    assert output == p.output()

def test_Parser_generate_type_error():
    p = Parser('');
    p.generate(b'0')
    p.generate(b'1')
    with pytest.raises(p.ParseError) as ex:
        p.generate('a')
    assert ex.match('Cannot generate '
        "'a': <class 'str'> not an instance of <class 'bytes'>")
    p.commit()
    assert b'01' == p.output(), "should not have added 'a'"

def test_Parser_generate_commit():
    p = Parser('')
    p.generate(b'a1');  assert    None is p.output()
    p.commit();         assert   b'a1' == p.output()
    p.generate(b'b2');  assert   b'a1' == p.output()
    p.commit();         assert b'a1b2' == p.output()


####################################################################
#   Parser control tests

def test_Parser_finished():
    assert Parser('').finished()

    p = Parser('1');    assert not p.finished()
    p.consume();        assert     p.finished()
    p.commit();         assert     p.finished()

def test_parser_reset_noarg():
    p = Parser('abc123');   assert 'abc' == p.consume(3)
    p.commit();             assert '123' == p.consume(3)
    p.reset();              assert 'abc' == p.consume(3)

def test_parser_reset_newinput_same_type():
    p = Parser(b'abc');     assert b'abc' == p.consume(3)
    p.reset(b'def');        assert b'def' == p.consume(3)

def test_parser_reset_newinput_different_type():
    p = Parser(b'abc')
    with pytest.raises(ValueError) as ex:
        p.reset('abc')
    assert ex.match("reset: new input sequence type <class 'str'>" \
        " not instance of old input sequence type <class 'bytes'>")

    p = Parser([1, 2, 3])
    with pytest.raises(ValueError) as ex:
        p.reset([1.1, 2.2, 3.3])
    assert ex.match("reset: new input element type <class 'float'>" \
        " not instance of old input element type <class 'int'>")

    p.reset([])

    p = Parser([])
    p.reset(['a', 'b', 'c'])



####################################################################
#   Parsing Routine Tests
#   From here on we generally test using `bytes` input to help
#   ensure that everything is using the codec properly.

class TestCodec:
    def trans(self, n):
        raise NotImplementedError("We don't think we need this.")
    def native(self, s):
        #   We rely on `ord()` to check that length of `s` is 1.
        return ord(s)

def test_Parser_peek():
    p = Parser(b'a', TestCodec())
    assert ord(b'a') == p.peek()
    assert b'a' == p.string('a')
    assert None == p.peek()

def test_Parser_string_str():
    p = Parser('abcd')
    s = p.string
    assert (   'a' ,     'bc' ,   None ,    'd') \
        == ( s('a'),   s('bc'),  s('e'),  s('d') )
    assert 'abcd' == p.uncommitted()
    p.commit()
    assert '' == p.remain()

def test_Parser_string_bytes():
    p = Parser(b'abcd', TestCodec())
    s = p.string
    assert ( b'a',   b'bc',    None,  b'd') \
        == (s('a'), s('bc'), s('e'), s('d'))
    assert b'abcd' == p.uncommitted()
    p.commit()
    assert b'' == p.remain()

def test_parser_string_in():
    p = Parser(b'abcd', TestCodec())
    #   Any iterable should work, so we use several different ones.

    p.start();
    assert b'ab' == p.string_in(set(['ab']))
    assert b'cd' == p.string_in(('cd',))

    p.start()
    assert  None is p.string_in(['xx', 'cd', 'xx'])
    assert b'ab' == p.string_in(['xx', 'ab', 'xx'])
    assert  None is p.string_in(['xx', 'ab', 'xx'])

@pytest.mark.parametrize('base, input, retvals', [
    #   The '5' below ensures we are not "using up" an iterator produced
    #   by map() in __init_constants, but have turned it into real data.
    (10, b'195ab',  (b'1', b'9', b'5', None)),
    ( 2, b'0123',   (b'0', b'1', None)),
    (16, b'aF0g',   (b'a', b'F', b'0', None)),
    ( 8, b'9',      (None,)),
    (10, b'',       (None,)),
])
def test_Parser_digit_bytes(base, input, retvals):
    p = Parser(input, TestCodec())
    assert retvals == tuple(( p.digit(base) for i in retvals ))

def test_Parser_digit_str():
    p = Parser('195ab', TestCodec())
    expected = ('1', '9', '5', None)
    assert expected == tuple(( p.digit(10) for i in expected ))

def test_Parser_digits():
    assert b'19' == Parser(b'19a', TestCodec()).digits()
    assert  None is Parser(b'',    TestCodec()).digits()

####################################################################
#   Token sorting and translation

TT_TABLE = (
    (b'\x02',       'bar',      None),
    (b'',           'f',        None),
    (b'\x01',       'foo',      None),
    (b'\x10\x20',   'foobar',   None),
)

def test_toksort_0_1():
    assert (
        (b'\x10\x20',   'foobar',   ),
        (b'\x02',       'bar'       ),
        (b'\x01',       'foo'       ),
        (b'',           'f'         ),
    ) == toksort(TT_TABLE)

def test_toksort_1_0():
    assert (
        ('foobar',  b'\x10\x20'),
        ('bar',     b'\x02'),
        ('foo',     b'\x01'),
        ('f',       b''),
    ) == toksort(TT_TABLE, 1, 0)

def test_Parser_token():
    p = Parser(b'ZfoofoobarbarffZ', TestCodec(), TT_TABLE)

    assert None is p.token()
    assert b'Z' == p.consume()

    def check(token, tokenized):
        assert token == p.token()
        p.commit()
        assert tokenized == p.olist_committed[-1]

    check('foo',    b'\x01')
    check('foobar', b'\x10\x20')
    check('bar',    b'\x02')
    check('f',      b'')
    check('f',      b'')

    assert b'Z' == p.consume()


####################################################################
####################################################################

####################################################################
#   PState reading/consumption

def test_PState_read_consume():
    p = PState('abcdef')

    assert (0, 'a', 'abcdef') == (p.pos, p.peek(), p.remain())

    s = p.consume()
    assert ('a', 1, 'b', 'bcdef') == (s, p.pos, p.peek(), p.remain())
    assert 'abcdef' == p.input, 'input should not be modified'

    s = p.consume(3)
    assert ('bcd', 4, 'e', 'ef') == (s, p.pos, p.peek(), p.remain())

    s = p.consume(2)
    assert ('ef', 6    , True        , True            , '') \
        == (s   , p.pos, p.finished(), None is p.peek(), p.remain())

    with pytest.raises(p.ParseError) as ex:
        p.consume()
    assert ex.match('Consumed past end of input: 7 > 6')

####################################################################
#   PState output generation

@pytest.mark.parametrize('output, olist', [
    ('01234',           ['01', '2', '3', '4']),
    (b'\x00\x01\x02',   [b'\x00', b'\x01\x02']),
    #   XXX It's not clear what we should give for the output if we can't
    #   figure out what type it should be, so for the moment, just None.
    (None,              []),
])
def test_PState_generate_output(output, olist):
    p = PState('');
    for o in olist:
        p.generate(o)
    assert output == p.output()

def test_PState_generate_outputtype():
    p = PState('');
    p.generate(b'0')
    p.generate(b'1')
    with pytest.raises(p.ParseError) as ex:
        p.generate('a')
    assert ex.match('Cannot generate '
        "'a': <class 'str'> not an instance of <class 'bytes'>")
    assert b'01' == p.output(), "should not have added 'a'"

####################################################################
#   Separate Parsing Routines

def test_byte_str():
    p = PState('hi')

    assert 'h' == byte(p)
    assert None is p.output()

    assert 'i' == byte(p, genf=lambda x: x)
    assert 'i' == p.output()

    assert None is byte(p, err=None)

    with pytest.raises(p.ParseError) as ex:
        byte(p)
    assert ex.match('unexpected end of input')

def test_byte_bytes():
    p = PState(b'hi')
    assert 0x68 == byte(p, genf=chr)
    assert 0x69 == byte(p, genf=lambda b: chr(b+1))
    assert 'hj' == p.output()

def test_toktrans():
    toktab = toksort(TT_TABLE, 1, 0)
    def tt(**kw): return toktrans(p, toktab, **kw)
    p = PState('ZfoofoobarbarffZ')

    assert None is tt(); byte(p)

    assert    'foo' == tt(); assert     b'\x01'== p.olist[-1]
    assert 'foobar' == tt(); assert b'\x10\x20'== p.olist[-1]
    assert    'bar' == tt(); assert     b'\x02'== p.olist[-1]
    assert      'f' == tt(); assert        b'' == p.olist[-1]
    assert      'f' == tt(); assert        b'' == p.olist[-1]

    #   No match.
    assert 5 == len(p.olist)
    assert (None, 5, 'Z') == (tt(), len(p.olist), p.peek())
    #   XXX Do we need a version that raises an error on no match?

    #   No more input.
    p.pos += 1; assert p.finished()
    assert (None, 5) == (tt(), len(p.olist))

    assert b'\x01\x10\x20\x02' == p.output()
