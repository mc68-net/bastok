from    bastok.parser  import *
import  struct
import  pytest

class TestCodec:
    def trans(self, n):
        raise NotImplementedError("We don't think we need this.")
    def native(self, s):
        #   We rely on `ord()` to check that length of `s` is 1.
        return ord(s)

def test_parser_consume_str():
    p = Parser('abc')
    c = p.consume
    assert ('a', 'bc', '') == (c(1), c(2), c(3))
    p.confirm()
    assert '' == p.remain()

def test_parser_consume_bytes():
    p = Parser(b'abc', TestCodec())
    c = p.consume
    assert (b'a', b'bc', b'') == (c(1), c(2), c(3))
    p.confirm()
    assert b'' == p.remain()

#   From here on we generally test using `bytes` input to help ensure
#   that everything is using the codec properly.

def test_Parser_confirmation():
    p = Parser(b'abcd')
    c = p.consume

    assert b'abcd' == p.remain()

    p.start()
    assert (b'a', b'abcd') == (c(), p.remain())
    assert (b'b', b'abcd') == (c(), p.remain())

    p.start()
    assert (b'a', b'abcd') == (c(), p.remain())
    assert (b'b', b'abcd') == (c(), p.remain())

    p.confirm()
    assert b'cd' == p.remain()

    p.start()
    assert (b'c', b'cd') == (c(), p.remain())

def test_Parser_string_str():
    p = Parser('abcd')
    s = p.string
    assert (  'a',    'bc',    None,   'd') \
        == (s('a'), s('bc'), s('e'), s('d'))

def test_Parser_string_bytes():
    p = Parser(b'abcd', TestCodec())
    s = p.string
    assert ( b'a',   b'bc',    None,  b'd') \
        == (s('a'), s('bc'), s('e'), s('d'))
    assert b'abcd' == p.remain()
    p.confirm()
    assert b'' == p.remain()

def test_Parser_peek():
    p = Parser(b'a', TestCodec())
    assert ord(b'a') == p.peek()
    assert b'a' == p.string('a')
    assert b'' == p.peek()

def test_Parser_decdigit():
    p = Parser(b'19ab', TestCodec())
    assert b'1' == p.decdigit()
    assert b'9' == p.decdigit()
    assert None is p.decdigit()



####################################################################
#   PState reading/consumption

def test_PState_read_consume():
    p = PState('abcdef')

    assert (0, 'a', 'abcdef') == (p.pos, p.peek(), p.remain())

    s = p.consume()
    assert ('a', 1, 'b', 'bcdef') == (s, p.pos, p.peek(), p.remain())
    assert 'abcdef' == p.input, 'input should not be modified'

    s = p.consume(3)
    assert ('bcd', 4, 'e', 'ef') == (s, p.pos, p.peek(), p.remain())

    s = p.consume(2)
    assert ('ef', 6    , True        , True            , '') \
        == (s   , p.pos, p.finished(), None is p.peek(), p.remain())

    with pytest.raises(p.ParseError) as ex:
        p.consume()
    assert ex.match('Consumed past end of input: 7 > 6')

####################################################################
#   PState output generation

@pytest.mark.parametrize('output, olist', [
    ('01234',           ['01', '2', '3', '4']),
    (b'\x00\x01\x02',   [b'\x00', b'\x01\x02']),
    #   XXX It's not clear what we should give for the output if we can't
    #   figure out what type it should be, so for the moment, just None.
    (None,              []),
])
def test_PState_generate_output(output, olist):
    p = PState('');
    for o in olist:
        p.generate(o)
    assert output == p.output()

def test_PState_generate_outputtype():
    p = PState('');
    p.generate(b'0')
    p.generate(b'1')
    with pytest.raises(p.ParseError) as ex:
        p.generate('a')
    assert ex.match('Cannot generate '
        "'a': <class 'str'> not an instance of <class 'bytes'>")
    assert b'01' == p.output(), "should not have added 'a'"

####################################################################
#   Separate Parsing Routines

def test_byte_str():
    p = PState('hi')

    assert 'h' == byte(p)
    assert None is p.output()

    assert 'i' == byte(p, genf=lambda x: x)
    assert 'i' == p.output()

    assert None is byte(p, err=None)

    with pytest.raises(p.ParseError) as ex:
        byte(p)
    assert ex.match('unexpected end of input')

def test_byte_bytes():
    p = PState(b'hi')
    assert 0x68 == byte(p, genf=chr)
    assert 0x69 == byte(p, genf=lambda b: chr(b+1))
    assert 'hj' == p.output()

####################################################################
#   Token sorting

TT_TABLE = (
    (b'\x02',       'bar',      None),
    (b'',           'f',        None),
    (b'\x01',       'foo',      None),
    (b'\x10\x20',   'foobar',   None),
)

def test_toksort_0_1():
    assert (
        (b'\x10\x20',   'foobar',   ),
        (b'\x02',       'bar'       ),
        (b'\x01',       'foo'       ),
        (b'',           'f'         ),
    ) == toksort(TT_TABLE)

def test_toksort_1_0():
    assert (
        ('foobar',  b'\x10\x20'),
        ('bar',     b'\x02'),
        ('foo',     b'\x01'),
        ('f',       b''),
    ) == toksort(TT_TABLE, 1, 0)

def test_toktrans():
    toktab = toksort(TT_TABLE, 1, 0)
    def tt(**kw): return toktrans(p, toktab, **kw)
    p = PState('ZfoofoobarbarffZ')

    assert None is tt(); byte(p)

    assert    'foo' == tt(); assert     b'\x01'== p.olist[-1]
    assert 'foobar' == tt(); assert b'\x10\x20'== p.olist[-1]
    assert    'bar' == tt(); assert     b'\x02'== p.olist[-1]
    assert      'f' == tt(); assert        b'' == p.olist[-1]
    assert      'f' == tt(); assert        b'' == p.olist[-1]

    #   No match.
    assert 5 == len(p.olist)
    assert (None, 5, 'Z') == (tt(), len(p.olist), p.peek())
    #   XXX Do we need a version that raises an error on no match?

    #   No more input.
    p.pos += 1; assert p.finished()
    assert (None, 5) == (tt(), len(p.olist))

    assert b'\x01\x10\x20\x02' == p.output()
