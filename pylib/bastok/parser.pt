from    bastok.parser  import *
import  struct
import  pytest

####################################################################
#   PState reading/consumption

def test_PState_read_consume():
    p = PState('abcdef')

    assert (0, 'a', 'abcdef') == (p.pos, p.peek(), p.remain())

    s = p.consume()
    assert ('a', 1, 'b', 'bcdef') == (s, p.pos, p.peek(), p.remain())
    assert 'abcdef' == p.input, 'input should not be modified'

    s = p.consume(3)
    assert ('bcd', 4, 'e', 'ef') == (s, p.pos, p.peek(), p.remain())

    s = p.consume(2)
    assert ('ef', 6    , True        , True            , '') \
        == (s   , p.pos, p.finished(), None is p.peek(), p.remain())

    with pytest.raises(p.ParseError) as ex:
        p.consume()
    assert ex.match('Consumed past end of input: 7 > 6')

####################################################################
#   PState output generation

@pytest.mark.parametrize('output, olist', [
    ('01234',           ['01', '2', '3', '4']),
    (b'\x00\x01\x02',   [b'\x00', b'\x01\x02']),
    #   XXX It's not clear what we should give for the output if we can't
    #   figure out what type it should be, so for the moment, just None.
    (None,              []),
])
def test_PState_generate_output(output, olist):
    p = PState('');
    for o in olist:
        p.generate(o)
    assert output == p.output()

def test_PState_generate_outputtype():
    p = PState('');
    p.generate(b'0')
    p.generate(b'1')
    with pytest.raises(p.ParseError) as ex:
        p.generate('a')
    assert ex.match('Cannot generate '
        "'a': <class 'str'> not an instance of <class 'bytes'>")
    assert b'01' == p.output(), "should not have added 'a'"

####################################################################
#   Separate Parsing Routines

def test_byte_str():
    p = PState('hi')

    assert 'h' == byte(p)
    assert None is p.output()

    assert 'i' == byte(p, genf=lambda x: x)
    assert 'i' == p.output()

    assert None is byte(p, err=None)

    with pytest.raises(p.ParseError) as ex:
        byte(p)
    assert ex.match('unexpected end of input')

def test_byte_bytes():
    p = PState(b'hi')
    assert 0x68 == byte(p, genf=chr)
    assert 0x69 == byte(p, genf=lambda b: chr(b+1))
    assert 'hj' == p.output()

@pytest.mark.parametrize('n, pos, s', [
    (0, 1, '0'), (0, 3, '000'),
    (17, 2, '17'), (17, 5, '00017'), (65535, 5, '65535'),
    (0, 1, '0 '), (0, 1, '0:'), (0, 1, '0a'), (0, 1, '0x'),
])
def test_uint16_success(n, pos, s):
    p = PState(s)
    tok = b'\x0E' + struct.pack('<H', n)
    assert (n        , tok        , pos) \
        == (uint16(p), p.output() , p.pos)

def test_uint16_nogen():
    p = PState('258')
    assert 258 == uint16(p, False)
    assert None is p.output()

def test_uint16_failure_letters():
    p = PState('-123')
    assert None == uint16(p)
    with pytest.raises(p.ParseError) as ex:
        uint16(p, err='uint16')
    assert ex.match('uint16')

def test_uint16_failure_size():
    p = PState('65536')
    with pytest.raises(p.ParseError) as ex:
        #   Should raise error even if not generating.
        uint16(p, gen=False, err='xyz')
    assert ex.match('65536 outside uint16 range at')

####################################################################
#   Token sorting

TT_TABLE = (
    (b'\x02',       'bar',      None),
    (b'',           'f',        None),
    (b'\x01',       'foo',      None),
    (b'\x10\x20',   'foobar',   None),
)

def test_toksort_0_1():
    assert (
        (b'\x10\x20',   'foobar',   ),
        (b'\x02',       'bar'       ),
        (b'\x01',       'foo'       ),
        (b'',           'f'         ),
    ) == toksort(TT_TABLE)

def test_toksort_1_0():
    assert (
        ('foobar',  b'\x10\x20'),
        ('bar',     b'\x02'),
        ('foo',     b'\x01'),
        ('f',       b''),
    ) == toksort(TT_TABLE, 1, 0)

def test_toktrans():
    toktab = toksort(TT_TABLE, 1, 0)
    def tt(**kw): return toktrans(p, toktab, **kw)
    p = PState('ZfoofoobarbarffZ')

    assert None is tt(); byte(p)

    assert    'foo' == tt(); assert     b'\x01'== p.olist[-1]
    assert 'foobar' == tt(); assert b'\x10\x20'== p.olist[-1]
    assert    'bar' == tt(); assert     b'\x02'== p.olist[-1]
    assert      'f' == tt(); assert        b'' == p.olist[-1]
    assert      'f' == tt(); assert        b'' == p.olist[-1]

    #   No match.
    assert 5 == len(p.olist)
    assert (None, 5, 'Z') == (tt(), len(p.olist), p.peek())
    #   XXX Do we need a version that raises an error on no match?

    #   No more input.
    p.pos += 1; assert p.finished()
    assert (None, 5) == (tt(), len(p.olist))

    assert b'\x01\x10\x20\x02' == p.output()
